// DO NOT EDIT; automatically generated by brio-gen

package hbimpl

import (
	"encoding/binary"
	"math"
)

// MarshalBinary implements encoding.BinaryMarshaler
func (o *dist0D) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.n))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.sumW))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.sumW2))
	data = append(data, buf[:8]...)
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *dist0D) UnmarshalBinary(data []byte) (err error) {
	o.n = int64(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.sumW = math.Float64frombits(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.sumW2 = math.Float64frombits(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	return err
}

// MarshalBinary implements encoding.BinaryMarshaler
func (o *dist1D) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	{
		sub, err := o.dist.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.sumWX))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.sumWX2))
	data = append(data, buf[:8]...)
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *dist1D) UnmarshalBinary(data []byte) (err error) {
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.dist.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	o.sumWX = math.Float64frombits(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.sumWX2 = math.Float64frombits(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	return err
}

// MarshalBinary implements encoding.BinaryMarshaler
func (o *dist2D) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	{
		sub, err := o.x.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	{
		sub, err := o.y.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.sumWXY))
	data = append(data, buf[:8]...)
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *dist2D) UnmarshalBinary(data []byte) (err error) {
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.x.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.y.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	o.sumWXY = math.Float64frombits(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	return err
}
